<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>moog.state_initialization.sprite_generators API documentation</title>
<meta name="description" content="Generators for producing lists of sprites based on factor distributions.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moog.state_initialization.sprite_generators</code></h1>
</header>
<section id="section-intro">
<p>Generators for producing lists of sprites based on factor distributions.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="moog.state_initialization.sprite_generators.chain_generators"><code class="name flex">
<span>def <span class="ident">chain_generators</span></span>(<span>*sprite_generators)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chain_generators(*sprite_generators):
    &#34;&#34;&#34;Chain generators by concatenating output sprite sequences.

    Essentially an &#39;AND&#39; operation over sprite generators. This is useful when
    one wants to control the number of samples from the modes of a multimodal
    sprite distribution.

    Note that factor_distributions.Mixture provides weighted mixture
    distributions, so chain_generators() is typically only used when one wants
    to forces the different modes to each have a non-zero number of sprites.

    Args:
        *sprite_generators: Callable sprite generators.

    Returns:
        _generate: Callable returning a list of sprites.
    &#34;&#34;&#34;

    def _generate(*args, **kwargs):
        return list(itertools.chain(*[generator(*args, **kwargs)
                                      for generator in sprite_generators]))

    return _generate</code></pre>
</details>
<div class="desc"><p>Chain generators by concatenating output sprite sequences.</p>
<p>Essentially an 'AND' operation over sprite generators. This is useful when
one wants to control the number of samples from the modes of a multimodal
sprite distribution.</p>
<p>Note that factor_distributions.Mixture provides weighted mixture
distributions, so chain_generators() is typically only used when one wants
to forces the different modes to each have a non-zero number of sprites.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*sprite_generators</code></strong></dt>
<dd>Callable sprite generators.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_generate</code></dt>
<dd>Callable returning a list of sprites.</dd>
</dl></div>
</dd>
<dt id="moog.state_initialization.sprite_generators.generate_sprites"><code class="name flex">
<span>def <span class="ident">generate_sprites</span></span>(<span>factor_dist, num_sprites=1, max_recursion_depth=10000, fail_gracefully=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_sprites(factor_dist,
                     num_sprites=1,
                     max_recursion_depth=int(1e4),
                     fail_gracefully=False):
    &#34;&#34;&#34;Create callable that samples sprites from a factor distribution.

    Example usage:
        ```python
        sprite_factors = distribs.Product(
            [distribs.Continuous(&#39;x&#39;, 0.2, 0.8),
             distribs.Continuous(&#39;y&#39;, 0.2, 0.8),
             distribs.Continuous(&#39;x_vel&#39;, -0.03, 0.03),
             distribs.Continuous(&#39;y_vel&#39;, -0.03, 0.03)],
            shape=&#39;circle, scale=0.1, c0=255, c1=0, c2=0,
        )
        sprite_gen = sprite_generators.generate_sprites(
            sprite_factors, num_sprites=lambda: np.random.randint(3, 6))
        
        def _state_initializer():
            ...
            other_sprites = ...
            ...
            sprites = sprite_gen(
                disjount=True, without_overlapping=other_sprites)
            state = collections.OrderedDict([
                (&#39;other_sprites&#39;, other_sprites),
                (&#39;sprites&#39;, sprites),
            ])
        ```

    Args:
        factor_dist: The factor distribution from which to sample. Should be an
            instance of spriteworld.factor_distributions.AbstractDistribution.
        num_sprites: Int or callable returning int. Number of sprites to
            generate per call.
        max_recursion_depth: Int. Maximum recursion depth when rejection
            sampling to generate sprites without overlap.
        fail_gracefully: Bool. Whether to return a list of sprites or raise
            RecursionError if max_recursion_depth is exceeded.

    Returns:
        _generate: Callable that returns a list of Sprites.
    &#34;&#34;&#34;
    def _overlaps(s, other_sprites):
        &#34;&#34;&#34;Whether s overlaps any sprite in other_sprites.&#34;&#34;&#34;
        if len(other_sprites) == 0:
            return False
        else:
            overlaps = [s.overlaps_sprite(x) for x in other_sprites]
            return any(overlaps)

    def _generate(disjoint=False, without_overlapping=[]):
        &#34;&#34;&#34;Return a list of sprites.
        
        Args:
            disjoint: Boolean. If true, all generated sprites will be disjoint.
            without_overlapping: Optional iterable of ../sprite/Sprite
                instances. If specified, all generated sprites will not overlap
                any sprites in without_overlapping.
        &#34;&#34;&#34;
        n = num_sprites() if callable(num_sprites) else num_sprites
        sprites = []
        for _ in range(n):
            s = sprite.Sprite(**factor_dist.sample())
            count = 0
            while _overlaps(s, without_overlapping):
                if count &gt; max_recursion_depth:
                    if fail_gracefully:
                        return sprites
                    else:
                        raise RecursionError(
                            &#39;max_recursion_depth exceeded trying to initialize &#39;
                            &#39;a non-overlapping sprite.&#39;)
                count += 1
                s = sprite.Sprite(**factor_dist.sample())
            sprites.append(s)
            if disjoint:
                without_overlapping = without_overlapping + [s]
        
        return sprites

    return _generate</code></pre>
</details>
<div class="desc"><p>Create callable that samples sprites from a factor distribution.</p>
<p>Example usage:
```python
sprite_factors = distribs.Product(
[distribs.Continuous('x', 0.2, 0.8),
distribs.Continuous('y', 0.2, 0.8),
distribs.Continuous('x_vel', -0.03, 0.03),
distribs.Continuous('y_vel', -0.03, 0.03)],
shape='circle, scale=0.1, c0=255, c1=0, c2=0,
)
sprite_gen = sprite_generators.generate_sprites(
sprite_factors, num_sprites=lambda: np.random.randint(3, 6))</p>
<pre><code>def _state_initializer():
    ...
    other_sprites = ...
    ...
    sprites = sprite_gen(
        disjount=True, without_overlapping=other_sprites)
    state = collections.OrderedDict([
        ('other_sprites', other_sprites),
        ('sprites', sprites),
    ])
```
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor_dist</code></strong></dt>
<dd>The factor distribution from which to sample. Should be an
instance of spriteworld.factor_distributions.AbstractDistribution.</dd>
<dt><strong><code>num_sprites</code></strong></dt>
<dd>Int or callable returning int. Number of sprites to
generate per call.</dd>
<dt><strong><code>max_recursion_depth</code></strong></dt>
<dd>Int. Maximum recursion depth when rejection
sampling to generate sprites without overlap.</dd>
<dt><strong><code>fail_gracefully</code></strong></dt>
<dd>Bool. Whether to return a list of sprites or raise
RecursionError if max_recursion_depth is exceeded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_generate</code></dt>
<dd>Callable that returns a list of Sprites.</dd>
</dl></div>
</dd>
<dt id="moog.state_initialization.sprite_generators.sample_generator"><code class="name flex">
<span>def <span class="ident">sample_generator</span></span>(<span>sprite_generators, p=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_generator(sprite_generators, p=None):
    &#34;&#34;&#34;Sample one element from a set of sprite generators.

    Essential an &#39;OR&#39; operation over sprite generators. This returns a callable
    that samples a generator from sprite_generators and calls it.

    Note that if sprite_generators each return 1 sprite, this functionality can
    be achieved with spriteworld.factor_distributions.Mixture, so
    sample_generator is typically used when sprite_generators each return
    multiple sprites. Effectively it allows dependant sampling from a multimodal
    factor distribution.

    Args:
        sprite_generators: Iterable of callable sprite generators.
        p: Probabilities associated with each generator. If None, assumes
            uniform distribution.

    Returns:
        _generate: Callable sprite generator.
    &#34;&#34;&#34;

    def _generate(*args, **kwargs):
        sampled_generator = np.random.choice(sprite_generators, p=p)
        return sampled_generator(*args, **kwargs)

    return _generate</code></pre>
</details>
<div class="desc"><p>Sample one element from a set of sprite generators.</p>
<p>Essential an 'OR' operation over sprite generators. This returns a callable
that samples a generator from sprite_generators and calls it.</p>
<p>Note that if sprite_generators each return 1 sprite, this functionality can
be achieved with spriteworld.factor_distributions.Mixture, so
sample_generator is typically used when sprite_generators each return
multiple sprites. Effectively it allows dependant sampling from a multimodal
factor distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sprite_generators</code></strong></dt>
<dd>Iterable of callable sprite generators.</dd>
<dt><strong><code>p</code></strong></dt>
<dd>Probabilities associated with each generator. If None, assumes
uniform distribution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_generate</code></dt>
<dd>Callable sprite generator.</dd>
</dl></div>
</dd>
<dt id="moog.state_initialization.sprite_generators.shuffle"><code class="name flex">
<span>def <span class="ident">shuffle</span></span>(<span>sprite_generator)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle(sprite_generator):
    &#34;&#34;&#34;Randomize the order of sprites sample from sprite_generator.

    This is useful because sprites are z-layered with occlusion according to
    their order, so if sprite_generator is the output of chain_generators(),
    then sprites from some component distributions will always be behind sprites
    from others.

    An alternate design would be to let the environment handle sprite ordering,
    but this design is preferable because the order can be controlled more
    finely. For example, this allows the user to specify one sprite (e.g. the
    agent&#39;s body) to always be in the foreground while all the others are
    randomly ordered.

    Args:
        sprite_generator: Callable return a list of sprites.

    Returns:
        _generate: Callable sprite generator.
    &#34;&#34;&#34;

    def _generate(*args, **kwargs):
        sprites = sprite_generator(*args, **kwargs)
        order = np.arange(len(sprites))
        np.random.shuffle(order)
        return [sprites[i] for i in order]

    return _generate</code></pre>
</details>
<div class="desc"><p>Randomize the order of sprites sample from sprite_generator.</p>
<p>This is useful because sprites are z-layered with occlusion according to
their order, so if sprite_generator is the output of chain_generators(),
then sprites from some component distributions will always be behind sprites
from others.</p>
<p>An alternate design would be to let the environment handle sprite ordering,
but this design is preferable because the order can be controlled more
finely. For example, this allows the user to specify one sprite (e.g. the
agent's body) to always be in the foreground while all the others are
randomly ordered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sprite_generator</code></strong></dt>
<dd>Callable return a list of sprites.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_generate</code></dt>
<dd>Callable sprite generator.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moog.state_initialization" href="index.html">moog.state_initialization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="moog.state_initialization.sprite_generators.chain_generators" href="#moog.state_initialization.sprite_generators.chain_generators">chain_generators</a></code></li>
<li><code><a title="moog.state_initialization.sprite_generators.generate_sprites" href="#moog.state_initialization.sprite_generators.generate_sprites">generate_sprites</a></code></li>
<li><code><a title="moog.state_initialization.sprite_generators.sample_generator" href="#moog.state_initialization.sprite_generators.sample_generator">sample_generator</a></code></li>
<li><code><a title="moog.state_initialization.sprite_generators.shuffle" href="#moog.state_initialization.sprite_generators.shuffle">shuffle</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
