<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>moog.state_initialization.distributions API documentation</title>
<meta name="description" content="Factor distribution library â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moog.state_initialization.distributions</code></h1>
</header>
<section id="section-intro">
<p>Factor distribution library.</p>
<p>This library contains classes for defining distributions of sprite factors.
A number of set-theoretic operations are supported, with which it is possible to
define factor distributions that are arbitrarily nested mixtures, intersections,
products, and differences of single-factor continuous/discrete distributions.</p>
<p>A factor specification is called a "spec", which is a dictionary of sprite
factors, hence can have keys such as "size", "shape", "x_pos", etc. However, the
classes in this file are general and make no reference to the particular factor
names used by Spriteworld sprites.</p>
<p>All distributions inherit from AbstractDistribution. They have a "sample()"
method, which returns a spec. The keys of this spec can be accessed by the
"keys" property. Distributions also have a "contains(spec)" method, which checks
if the argument "spec" is in the support of the distribution.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="moog.state_initialization.distributions.AbstractDistribution"><code class="flex name class">
<span>class <span class="ident">AbstractDistribution</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractDistribution(abc.ABC):
    &#34;&#34;&#34;Abstract class from which all distributions should inherit.&#34;&#34;&#34;

    @abc.abstractmethod
    def sample(self, rng=None):
        &#34;&#34;&#34;Sample a spec from this distribution. Returns a dictionary.
        
        Args:
            rng: Random number generator. Fed into self._get_rng(), if None
                defaults to np.random.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def contains(self, spec):
        &#34;&#34;&#34;Return whether distribution contains spec dictionary.&#34;&#34;&#34;

    @abc.abstractmethod
    def to_str(self, indent):
        &#34;&#34;&#34;Recursive string description of this distribution.&#34;&#34;&#34;

    def __str__(self):
        return self.to_str(indent=0)

    def _get_rng(self, rng=None):
        &#34;&#34;&#34;Get random number generator, defaulting to np.random.&#34;&#34;&#34;
        return np.random if rng is None else rng

    @abc.abstractproperty
    def keys(self):
        &#34;&#34;&#34;The set of keys in specs sampled from this distribution.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Abstract class from which all distributions should inherit.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.Continuous" href="#moog.state_initialization.distributions.Continuous">Continuous</a></li>
<li><a title="moog.state_initialization.distributions.DependentDistribution" href="#moog.state_initialization.distributions.DependentDistribution">DependentDistribution</a></li>
<li><a title="moog.state_initialization.distributions.Discrete" href="#moog.state_initialization.distributions.Discrete">Discrete</a></li>
<li><a title="moog.state_initialization.distributions.Intersection" href="#moog.state_initialization.distributions.Intersection">Intersection</a></li>
<li><a title="moog.state_initialization.distributions.Mixture" href="#moog.state_initialization.distributions.Mixture">Mixture</a></li>
<li><a title="moog.state_initialization.distributions.Product" href="#moog.state_initialization.distributions.Product">Product</a></li>
<li><a title="moog.state_initialization.distributions.Selection" href="#moog.state_initialization.distributions.Selection">Selection</a></li>
<li><a title="moog.state_initialization.distributions.SetMinus" href="#moog.state_initialization.distributions.SetMinus">SetMinus</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="moog.state_initialization.distributions.AbstractDistribution.keys"><code class="name">prop <span class="ident">keys</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def keys(self):
    &#34;&#34;&#34;The set of keys in specs sampled from this distribution.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>The set of keys in specs sampled from this distribution.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="moog.state_initialization.distributions.AbstractDistribution.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, spec)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def contains(self, spec):
    &#34;&#34;&#34;Return whether distribution contains spec dictionary.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Return whether distribution contains spec dictionary.</p></div>
</dd>
<dt id="moog.state_initialization.distributions.AbstractDistribution.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, rng=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def sample(self, rng=None):
    &#34;&#34;&#34;Sample a spec from this distribution. Returns a dictionary.
    
    Args:
        rng: Random number generator. Fed into self._get_rng(), if None
            defaults to np.random.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Sample a spec from this distribution. Returns a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rng</code></strong></dt>
<dd>Random number generator. Fed into self._get_rng(), if None
defaults to np.random.</dd>
</dl></div>
</dd>
<dt id="moog.state_initialization.distributions.AbstractDistribution.to_str"><code class="name flex">
<span>def <span class="ident">to_str</span></span>(<span>self, indent)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def to_str(self, indent):
    &#34;&#34;&#34;Recursive string description of this distribution.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Recursive string description of this distribution.</p></div>
</dd>
</dl>
</dd>
<dt id="moog.state_initialization.distributions.Continuous"><code class="flex name class">
<span>class <span class="ident">Continuous</span></span>
<span>(</span><span>key, minval, maxval, dtype='float32')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Continuous(AbstractDistribution):
    &#34;&#34;&#34;Continuous 1-dimensional uniform distribution.&#34;&#34;&#34;

    def __init__(self, key, minval, maxval, dtype=&#39;float32&#39;):
        &#34;&#34;&#34;Construct continuous 1-dimensional uniform distribution.
        
        Args:
            key: String factor name. self.sample() returns {key: _}.
            minval: Scalar minimum value.
            maxval: Scalar maximum value.
            dtype: String numpy dtype.
        &#34;&#34;&#34;
        self.key = key
        self.minval = minval
        self.maxval = maxval
        self.dtype = dtype

    def sample(self, rng=None):
        &#34;&#34;&#34;Sample value in [self.minval, self.maxval) and return dict.&#34;&#34;&#34;
        rng = self._get_rng(rng)
        out = rng.uniform(low=self.minval, high=self.maxval)
        out = np.asarray(out, dtype=self.dtype)
        return {self.key: out}

    def contains(self, spec):
        &#34;&#34;&#34;Check if spec[self.key] is in [self.minval, self.maxval).&#34;&#34;&#34;
        if self.key not in spec:
            raise KeyError(&#39;key {} is not in spec {}, but must be to evaluate &#39;
                           &#39;containment.&#39;.format(self.key, spec))
        else:
            return (
                spec[self.key] &gt;= self.minval and spec[self.key] &lt; self.maxval)

    def to_str(self, indent):
        s = &#39;&lt;Continuous: key={}, mival={}, maxval={}, dtype={}&gt;&#39;.format(
            self.key, self.minval, self.maxval, self.dtype)
        return indent * &#39;  &#39; + s

    @property
    def keys(self):
        return set([self.key])</code></pre>
</details>
<div class="desc"><p>Continuous 1-dimensional uniform distribution.</p>
<p>Construct continuous 1-dimensional uniform distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>String factor name. self.sample() returns {key: _}.</dd>
<dt><strong><code>minval</code></strong></dt>
<dd>Scalar minimum value.</dd>
<dt><strong><code>maxval</code></strong></dt>
<dd>Scalar maximum value.</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>String numpy dtype.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moog.state_initialization.distributions.Continuous.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, spec)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, spec):
    &#34;&#34;&#34;Check if spec[self.key] is in [self.minval, self.maxval).&#34;&#34;&#34;
    if self.key not in spec:
        raise KeyError(&#39;key {} is not in spec {}, but must be to evaluate &#39;
                       &#39;containment.&#39;.format(self.key, spec))
    else:
        return (
            spec[self.key] &gt;= self.minval and spec[self.key] &lt; self.maxval)</code></pre>
</details>
<div class="desc"><p>Check if spec[self.key] is in [self.minval, self.maxval).</p></div>
</dd>
<dt id="moog.state_initialization.distributions.Continuous.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, rng=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, rng=None):
    &#34;&#34;&#34;Sample value in [self.minval, self.maxval) and return dict.&#34;&#34;&#34;
    rng = self._get_rng(rng)
    out = rng.uniform(low=self.minval, high=self.maxval)
    out = np.asarray(out, dtype=self.dtype)
    return {self.key: out}</code></pre>
</details>
<div class="desc"><p>Sample value in [self.minval, self.maxval) and return dict.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.DependentDistribution"><code class="flex name class">
<span>class <span class="ident">DependentDistribution</span></span>
<span>(</span><span>independent_distrib, dependent_fn, dependent_fn_keys)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DependentDistribution(AbstractDistribution):
    &#34;&#34;&#34;Distibution in which some factors depend deterministically on others.
    
    For example, suppose you want a distribution over keys [&#39;x&#39;, &#39;y&#39;] where
    values are floats in [0, 1] but y = 1 - x. This could be done with:
    ```python
        DependentDistribution(
            independent_distrib=Continuous(&#39;x&#39;, 0., 1.),
            dependent_fn=lambda indep_sample: {&#39;y&#39;: 1. - indep_sample[&#39;x&#39;]},
            dependent_fn_keys=[&#39;y&#39;],
        )
    ```
    &#34;&#34;&#34;

    def __init__(self, independent_distrib, dependent_fn, dependent_fn_keys):
        &#34;&#34;&#34;Constructor.

        Args:
            independent_distrib: Instance of AbstractDistribution.
            dependent_fn: Function taking a sample from independent_distrib and
                returning a dictionary.
            dependent_fn_keys: Iterable of keys of the output of dependent_fn.
        &#34;&#34;&#34;
        self._independent_distrib = independent_distrib
        self._dependent_fn = dependent_fn
        self._dependent_fn_keys = dependent_fn_keys

        if not set(independent_distrib.keys).isdisjoint(set(dependent_fn_keys)):
            raise ValueError(
                &#39;independent_distrib keys {} and dependent_fn keys {} are not &#39;
                &#39;disjoint.&#39;.format(independent_distrib.keys, dependent_fn_keys))

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        sample = self._independent_distrib.sample(rng=rng)
        sample.update(self._dependent_fn(sample))
        return sample

    def contains(self, spec):
        contains = self._independent_distrib.contains(spec)
        sub_spec = {k: spec[k] for k in self._independent_distrib.keys}
        dependent_fn_sub_spec = self._dependent_fn(sub_spec)
        for k in self._dependent_fn_keys:
            contains &amp;= spec[k] == dependent_fn_sub_spec[k]
        return contains

    @property
    def keys(self):
        return self._independent_distrib.keys.union(self._dependent_fn_keys)

    def to_str(self, indent):
        s = (indent * &#39;  &#39; + &#39;&lt;DependentDistribution:\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;independent_distrib=\n{},\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;dependent_fn={}&gt;&#39;).format(
                self._independent_distrib, self._dependent_fn)
        return s</code></pre>
</details>
<div class="desc"><p>Distibution in which some factors depend deterministically on others.</p>
<p>For example, suppose you want a distribution over keys ['x', 'y'] where
values are floats in [0, 1] but y = 1 - x. This could be done with:</p>
<pre><code class="language-python">    DependentDistribution(
        independent_distrib=Continuous('x', 0., 1.),
        dependent_fn=lambda indep_sample: {'y': 1. - indep_sample['x']},
        dependent_fn_keys=['y'],
    )
</code></pre>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>independent_distrib</code></strong></dt>
<dd>Instance of AbstractDistribution.</dd>
<dt><strong><code>dependent_fn</code></strong></dt>
<dd>Function taking a sample from independent_distrib and
returning a dictionary.</dd>
<dt><strong><code>dependent_fn_keys</code></strong></dt>
<dd>Iterable of keys of the output of dependent_fn.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.Discrete"><code class="flex name class">
<span>class <span class="ident">Discrete</span></span>
<span>(</span><span>key, candidates, probs=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Discrete(AbstractDistribution):
    &#34;&#34;&#34;Discrete distribution.&#34;&#34;&#34;

    def __init__(self, key, candidates, probs=None):
        &#34;&#34;&#34;Construct discrete distribution.
        
        Args:
            key: String. Factor name.
            candidates: Iterable. Discrete values to sample from.
            probs: None or iterable of floats summing to 1. Candidate sampling
                probabilities. If None, candidates are sampled uniformly.
        &#34;&#34;&#34;
        self.candidates = candidates
        self.key = key
        self.probs = probs

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        out = self.candidates[rng.choice(len(self.candidates), p=self.probs)]
        return {self.key: out}

    def contains(self, spec):
        if self.key not in spec:
            raise KeyError(&#39;key {} is not in spec {}, but must be to evaluate &#39;
                           &#39;containment.&#39;.format(self.key, spec))
        else:
            return spec[self.key] in self.candidates

    def to_str(self, indent):
        s = &#39;&lt;Discrete: key={}, candidates={}, probs={}&gt;&#39;.format(
            self.key, self.candidates, self.probs)
        return indent * &#39;  &#39; + s

    @property
    def keys(self):
        return set([self.key])</code></pre>
</details>
<div class="desc"><p>Discrete distribution.</p>
<p>Construct discrete distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>String. Factor name.</dd>
<dt><strong><code>candidates</code></strong></dt>
<dd>Iterable. Discrete values to sample from.</dd>
<dt><strong><code>probs</code></strong></dt>
<dd>None or iterable of floats summing to 1. Candidate sampling
probabilities. If None, candidates are sampled uniformly.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.Intersection"><code class="flex name class">
<span>class <span class="ident">Intersection</span></span>
<span>(</span><span>components, index_for_sampling=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Intersection(AbstractDistribution):
    &#34;&#34;&#34;Intersection of component distributions.&#34;&#34;&#34;

    def __init__(self, components, index_for_sampling=0):
        &#34;&#34;&#34;Construct intersection of component distributions.
        
        Samples are generated by sampling from one of the components and then
        doing rejection with the others, so if the component being sampled has
        some non-uniformity (e.g. a mixture with non-uniform probs), that
        non-uniformity will be inherited by the intersection.
        
        Args:
            components: Iterable of distributions.
            index_for_sampling: Int. Index of the component to use for sampling.
                All other components will be used to reject its samples. For
                efficiency, the user should ensure index_for_sampling
                corresponds to the smallest component distribution.
        &#34;&#34;&#34;
        self.components = components
        self.index_for_sampling = index_for_sampling

        self._keys = components[0].keys
        for c in components[1:]:
            if c.keys != self._keys:
                raise ValueError(
                    &#39;All components must have the same key sets. However &#39;
                    &#39;detected key sets {} and {}&#39;.format(self._keys, c.keys))

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        tries = 0
        while tries &lt; _MAX_TRIES:
            tries += 1
            sample = self.components[self.index_for_sampling].sample(rng=rng)
            if all(c.contains(sample) for c in self.components):
                return sample
        raise ValueError(&#39;Maximum number of tried exceeded when trying to &#39;
                         &#39;sample from {}.&#39;.format(str(self)))

    def contains(self, spec):
        return all(c.contains(spec) for c in self.components)

    def to_str(self, indent):
        components_strings = [x.to_str(indent + 2) for x in self.components]
        s = (indent * &#39;  &#39; + &#39;&lt;Intersection:\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;components=[\n{},\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;],\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;index_for_sampling={}&gt;&#39;).format(
                &#39;,\n&#39;.join(components_strings), self.index_for_sampling)
        return s

    @property
    def keys(self):
        return self._keys</code></pre>
</details>
<div class="desc"><p>Intersection of component distributions.</p>
<p>Construct intersection of component distributions.</p>
<p>Samples are generated by sampling from one of the components and then
doing rejection with the others, so if the component being sampled has
some non-uniformity (e.g. a mixture with non-uniform probs), that
non-uniformity will be inherited by the intersection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>components</code></strong></dt>
<dd>Iterable of distributions.</dd>
<dt><strong><code>index_for_sampling</code></strong></dt>
<dd>Int. Index of the component to use for sampling.
All other components will be used to reject its samples. For
efficiency, the user should ensure index_for_sampling
corresponds to the smallest component distribution.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.Mixture"><code class="flex name class">
<span>class <span class="ident">Mixture</span></span>
<span>(</span><span>components, probs=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mixture(AbstractDistribution):
    &#34;&#34;&#34;Mixture of distributions.&#34;&#34;&#34;

    def __init__(self, components, probs=None):
        &#34;&#34;&#34;Construct mixture of distributions.
        
        This is a mixture distribution, not a union, so if the components
        overlap, their overlap will be sampled more than the non-overlapping
        regions.
        
        Args:
            components: Iterable of component distributions. Must all have the
                same key sets.
            probs: None or iterable of floats summing to 1. Sampling
                probabilities for the components.
        &#34;&#34;&#34;
        self.components = components
        if probs is None:
            self.probs = np.ones(len(components)) / len(components)
        else:
            self.probs = np.array(probs)

        self._keys = components[0].keys
        for c in components[1:]:
            if c.keys != self._keys:
                raise ValueError(
                    &#39;All components must have the same key sets. However &#39;
                    &#39;detected key sets {} and {}&#39;.format(self._keys, c.keys))

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        sample_index = rng.choice(len(self.components), p=self.probs)
        sample = self.components[sample_index].sample(rng=rng)
        return sample

    def contains(self, spec):
        return any(c.contains(spec) for c in self.components)

    def to_str(self, indent):
        components_strings = [x.to_str(indent + 2) for x in self.components]
        s = (indent * &#39;  &#39; + &#39;&lt;Mixture:\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;components=[\n{},\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;],\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;probs={}&gt;&#39;).format(
                &#39;,\n&#39;.join(components_strings), self.probs)
        return s

    @property
    def keys(self):
        return self._keys</code></pre>
</details>
<div class="desc"><p>Mixture of distributions.</p>
<p>Construct mixture of distributions.</p>
<p>This is a mixture distribution, not a union, so if the components
overlap, their overlap will be sampled more than the non-overlapping
regions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>components</code></strong></dt>
<dd>Iterable of component distributions. Must all have the
same key sets.</dd>
<dt><strong><code>probs</code></strong></dt>
<dd>None or iterable of floats summing to 1. Sampling
probabilities for the components.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.Product"><code class="flex name class">
<span>class <span class="ident">Product</span></span>
<span>(</span><span>components, **constants)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Product(AbstractDistribution):
    &#34;&#34;&#34;Product distribution.&#34;&#34;&#34;

    def __init__(self, components, **constants):
        &#34;&#34;&#34;Construct product distribution.
        
        This is used to create distributions over larger numbers of factors by
        taking the product of components. The components must have disjoint key
        sets.
        
        Args:
            components: Iterable of distributions.
            constants: Dictionary. Keys will be additional factors to the
                distribution and values will the constant values for those keys.
                So using constants is an easy way to effectively pass in extra
                Discrete 1-candidate distributions.
        &#34;&#34;&#34;
        constant_components = [Discrete(k, [v]) for k, v in constants.items()]
        components = list(components) + constant_components
        self.components = components

        self._keys = functools.reduce(
            set.union, [set(c.keys) for c in components])
        num_keys = sum(len(c.keys) for c in components)
        if len(self._keys) &lt; num_keys:
            raise ValueError(
                &#39;All components must have different keys, yet there are {} &#39;
                &#39;overlapping keys.&#39;.format(num_keys - len(self._keys)))

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        sample = {}
        for c in self.components:
            sample.update(c.sample(rng=rng))
        return sample

    def contains(self, spec):
        return all(c.contains(spec) for c in self.components)

    def to_str(self, indent):
        components_strings = [x.to_str(indent + 2) for x in self.components]
        s = (indent * &#39;  &#39; + &#39;&lt;Product:\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;components=[\n{},\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;]&gt;&#39;).format(
                &#39;,\n&#39;.join(components_strings))
        return s

    @property
    def keys(self):
        return self._keys</code></pre>
</details>
<div class="desc"><p>Product distribution.</p>
<p>Construct product distribution.</p>
<p>This is used to create distributions over larger numbers of factors by
taking the product of components. The components must have disjoint key
sets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>components</code></strong></dt>
<dd>Iterable of distributions.</dd>
<dt><strong><code>constants</code></strong></dt>
<dd>Dictionary. Keys will be additional factors to the
distribution and values will the constant values for those keys.
So using constants is an easy way to effectively pass in extra
Discrete 1-candidate distributions.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.Selection"><code class="flex name class">
<span>class <span class="ident">Selection</span></span>
<span>(</span><span>base, filtering)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Selection(AbstractDistribution):
    &#34;&#34;&#34;Filter a source distribution.&#34;&#34;&#34;

    def __init__(self, base, filtering):
        &#34;&#34;&#34;Construct selection of a base distribution given a filter.
        
        Given a base Distribution and a filter Distribution, returns samples of
        the base which are compatible with the filter.
        
        This is related to Intersection, but does not expect the base and
        filters to have the same keys. Instead, the filters should be subsets of
        the base. This is the same as SetMinus, except the filter accepts
        instead of rejects samples.

        Args:
            base: Distribution from which candidate samples are drawn.
            filtering: Distribution used to select samples from base.
        &#34;&#34;&#34;
        self.base = base
        self.filtering = filtering

        self._keys = base.keys
        if not filtering.keys.issubset(self._keys):
            raise ValueError(
                &#39;Keys {} of filtering is not a subset of keys {} of Selection &#39;
                &#39;base distribution.&#39;.format(filtering.keys, base.keys))

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        tries = 0
        while tries &lt; _MAX_TRIES:
            tries += 1
            sample = self.base.sample(rng=rng)
            if self.filtering.contains(sample):
                return sample
        raise ValueError(
            &#39;Maximum number of tried exceeded when trying to sample from {}.&#39;
            .format(str(self)))

    def contains(self, spec):
        return self.base.contains(spec) and self.filtering.contains(spec)

    def to_str(self, indent):
        s = (indent * &#39;  &#39; + &#39;&lt;Selection:\n&#39; + (indent + 1) * &#39;  &#39; +
            &#39;base=\n{},\n&#39; + (indent + 1) * &#39;  &#39; + &#39;filtering=\n{}&gt;&#39;).format(
                self.base.to_str(indent + 2), self.filtering.to_str(indent + 2))
        return s

    @property
    def keys(self):
        return self._keys</code></pre>
</details>
<div class="desc"><p>Filter a source distribution.</p>
<p>Construct selection of a base distribution given a filter.</p>
<p>Given a base Distribution and a filter Distribution, returns samples of
the base which are compatible with the filter.</p>
<p>This is related to Intersection, but does not expect the base and
filters to have the same keys. Instead, the filters should be subsets of
the base. This is the same as SetMinus, except the filter accepts
instead of rejects samples.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base</code></strong></dt>
<dd>Distribution from which candidate samples are drawn.</dd>
<dt><strong><code>filtering</code></strong></dt>
<dd>Distribution used to select samples from base.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moog.state_initialization.distributions.SetMinus"><code class="flex name class">
<span>class <span class="ident">SetMinus</span></span>
<span>(</span><span>base, hold_out)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetMinus(AbstractDistribution):
    &#34;&#34;&#34;Setminus of distributions.&#34;&#34;&#34;

    def __init__(self, base, hold_out):
        &#34;&#34;&#34;Construct setminus of distributions..
        
        This uses rejection sampling to take the difference of two
        distributions.
        
        Args:
            base: Distribution from which candidate samples are drawn.
            hold_out: Distribution used to reject samples from base.
        &#34;&#34;&#34;
        self.base = base
        self.hold_out = hold_out

        self._keys = base.keys
        if not hold_out.keys.issubset(self._keys):
            raise ValueError(
                &#39;Keys {} of hold_out is not a subset of keys {} of SetMinus &#39;
                &#39;base distribution.&#39;.format(hold_out.keys, base.keys))

    def sample(self, rng=None):
        rng = self._get_rng(rng)
        tries = 0
        while tries &lt; _MAX_TRIES:
            tries += 1
            sample = self.base.sample(rng=rng)
            if not self.hold_out.contains(sample):
                return sample
        raise ValueError(&#39;Maximum number of tried exceeded when trying to &#39;
                         &#39;sample from {}.&#39;.format(str(self)))

    def contains(self, spec):
        return self.base.contains(spec) and not self.hold_out.contains(spec)

    def to_str(self, indent):
        s = (indent * &#39;  &#39; + &#39;&lt;SetMinus:\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;base=\n{},\n&#39; +
            (indent + 1) * &#39;  &#39; + &#39;hold_out=\n{}&gt;&#39;).format(
                self.base.to_str(indent + 2), self.hold_out.to_str(indent + 2))
        return s

    @property
    def keys(self):
        return self._keys</code></pre>
</details>
<div class="desc"><p>Setminus of distributions.</p>
<p>Construct setminus of distributions..</p>
<p>This uses rejection sampling to take the difference of two
distributions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base</code></strong></dt>
<dd>Distribution from which candidate samples are drawn.</dd>
<dt><strong><code>hold_out</code></strong></dt>
<dd>Distribution used to reject samples from base.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moog.state_initialization" href="index.html">moog.state_initialization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="moog.state_initialization.distributions.AbstractDistribution" href="#moog.state_initialization.distributions.AbstractDistribution">AbstractDistribution</a></code></h4>
<ul class="">
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.contains" href="#moog.state_initialization.distributions.AbstractDistribution.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.keys" href="#moog.state_initialization.distributions.AbstractDistribution.keys">keys</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.sample" href="#moog.state_initialization.distributions.AbstractDistribution.sample">sample</a></code></li>
<li><code><a title="moog.state_initialization.distributions.AbstractDistribution.to_str" href="#moog.state_initialization.distributions.AbstractDistribution.to_str">to_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.Continuous" href="#moog.state_initialization.distributions.Continuous">Continuous</a></code></h4>
<ul class="">
<li><code><a title="moog.state_initialization.distributions.Continuous.contains" href="#moog.state_initialization.distributions.Continuous.contains">contains</a></code></li>
<li><code><a title="moog.state_initialization.distributions.Continuous.sample" href="#moog.state_initialization.distributions.Continuous.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.DependentDistribution" href="#moog.state_initialization.distributions.DependentDistribution">DependentDistribution</a></code></h4>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.Discrete" href="#moog.state_initialization.distributions.Discrete">Discrete</a></code></h4>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.Intersection" href="#moog.state_initialization.distributions.Intersection">Intersection</a></code></h4>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.Mixture" href="#moog.state_initialization.distributions.Mixture">Mixture</a></code></h4>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.Product" href="#moog.state_initialization.distributions.Product">Product</a></code></h4>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.Selection" href="#moog.state_initialization.distributions.Selection">Selection</a></code></h4>
</li>
<li>
<h4><code><a title="moog.state_initialization.distributions.SetMinus" href="#moog.state_initialization.distributions.SetMinus">SetMinus</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
