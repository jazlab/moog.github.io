<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>moog.physics.collisions API documentation</title>
<meta name="description" content="Collision forces â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moog.physics.collisions</code></h1>
</header>
<section id="section-intro">
<p>Collision forces.</p>
<p>The main class in this file is Collision. It simulates Newtonian collisions
between two sprites. These collisions take into account the angles of the sprite
edges/vertices at the point of contact to realistically simulate the collision.
By default they respect Newtonian mechanics for rotation as well, taking into
consideration the moments of inertia of the sprites. However, there is an option
to ignore this and prohibit the collision from changing the angular velocity of
the sprites.</p>
<p>WARNING: Sprites must be star-shaped with respect to their center of mass (i.e.
the line fron the center of mass to any point in the sprite never exits the
sprite) for guaranteed correct collisions. If they are not star-shaped, there
can be rare events where two sprites collide at a corner and the collision is
not simulated correctly.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="moog.physics.collisions.Collision"><code class="flex name class">
<span>class <span class="ident">Collision</span></span>
<span>(</span><span>elasticity=1.0, symmetric=False, update_angle_vel=True, max_recursion_depth=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collision(abstract_force.AbstractForce):
    &#34;&#34;&#34;Collision simulator.
    
    This class simulates Newtonian collisions between two rigid bodies, namely
    sprites in the environment. The physics assumes that the sprites have
    uniform density, as this is important for calculating their moments of
    inertia (see ../sprite for details).
    &#34;&#34;&#34;

    def __init__(self, elasticity=1., symmetric=False, update_angle_vel=True,
                 max_recursion_depth=0):
        &#34;&#34;&#34;Constructor.
        
        Args:
            elasticity: Float in [0, 1]. Elasticity 1 means the sprites bounce
                fully. Elasticity 0 means they stick together completely.
            symmetric: Bool. If True, collision is symmetric and both sprites
                are updated. If False, sprite_1 in .step() is treated as having
                infinite mass. This is useful for modeling bounces off of
                obstructors/walls that are fixed in the environment.
            update_angle_vel: Bool. If True, fully simulate the rotational
                mechanics and update the sprites angular velocity. If False,
                sprite angular velocities are not updated and the collision is
                treated as if the contact point was between the two sprites&#39;
                centers of mass. Simulating the full rotational mechanics is
                slightly slower.
            max_recursion_depth: Int. Number of times self.step() may recurse.
                Usually, 0 (no recursion) is fine. However, larger values make
                the collisions slightly more accurate (at the expense of runtime
                efficiency) if multiple collisions are happening within a single
                step, e.g. colliding into a corner.
        &#34;&#34;&#34;
        self._elasticity = elasticity
        self._symmetric = symmetric
        self._update_angle_vel = update_angle_vel
        self._max_recursion_depth = max_recursion_depth

    def step(self, sprite_0, sprite_1, updates_per_env_step, recursion_depth=0):
        &#34;&#34;&#34;Step the physics.
        
        Args:
            sprite_0: Instance of ../sprite.Sprite. If self._symmetric = False,
                this sprite is the one that is doing the colliding, i.e. this
                one&#39;s velocity changes.
            sprite_1: Instance of ../sprite.Sprite. If self._symmetric = False,
                this sprite is treated as having infinite mass.
            updates_per_env_step: Int. Number of times this force step is called
                for each step of the physics in the environment. This is used
                here for inferring the exact contact point in the collision.
            recursion_depth: Int. Number of times this function has recursed.
                Used internally only to catch and avoid max recursion depth
                errors.
        &#34;&#34;&#34;
        if recursion_depth &gt; self._max_recursion_depth:
            return

        if sprite_0 == sprite_1:
            return

        if not sprite_0.overlaps_sprite(sprite_1):
            return

        delta_t = 1. / updates_per_env_step

        # First get collision point, normal, and relative sprite displacement
        # since the collision
        collision_point, collision_normal, _, perpendicular = (
            _get_collision_vectors(sprite_0, sprite_1, delta_t))
        
        if collision_point is None:
            # Although the sprites do overlap, neither sprite contains any of
            # the other&#39;s vertices. This can happen when the sprites collide
            # exactly at two corners. This is annoying to handle because we must
            # infer which corner hit which face in between timesteps, but must
            # be done to ensure stability. See self._make_disjoint() for
            # details.
            self._make_disjoint(sprite_0, sprite_1)
        else:
            # Whether the collision point is in the future, in which case we
            # leave the sprites alone.
            future_collision_point = (
                np.isscalar(collision_normal) and np.isnan(collision_normal))

            if not future_collision_point:
                # There was a collision in the past, so we must simulate it
                # First, displace the sprites so they are no longer intersecting
                # Note that instead of perpendicular displacement we could use
                # since_collision. However, sometimes since_collision can have a
                # very acute angle and large magnitude due to angular velocity
                # or multiple collisions, so in prectice displacing by the
                # perpendicular is more stable.
                if self._symmetric:
                    sprite_0.position = (
                        sprite_0.position - (0.5 + _EPSILON) * perpendicular)
                    sprite_1.position = (
                        sprite_1.position + (0.5 + _EPSILON) * perpendicular)
                else:
                    sprite_0.position = (
                        sprite_0.position - (1. + _EPSILON) * perpendicular)

                # Second, change sprite velocities and angular velocities per
                # Newtonian physics
                if self._update_angle_vel:
                    _collide_with_update_angle_vel(
                        sprite_0,
                        sprite_1,
                        collision_point,
                        collision_normal,
                        elasticity=self._elasticity,
                        symmetric=self._symmetric,
                    )
                else:
                    _collide_without_update_angle_vel(
                        sprite_0,
                        sprite_1,
                        collision_point,
                        collision_normal,
                        elasticity=self._elasticity,
                        symmetric=self._symmetric,
                    )
            else:
                return
            
        # After perturbing the sprite positions and velocities, we recursively
        # step again in case that perturbation has now created another
        # collision.
        self.step(sprite_0, sprite_1, updates_per_env_step,
                  recursion_depth=recursion_depth + 1)

    def _make_disjoint(self, sprite_0, sprite_1):
        &#34;&#34;&#34;Perturb the positions of sprite_0 and sprite_1 to make them disjoint.

        In theory, with infinitesimal delta_t, the collision detection would
        work without this correction since every collision occurs by a vertex of
        one sprite entering another sprite. However, with a non-zero delta_t, if
        a collision occurs almost exactly at two sharp corners of sprites, the
        vertex entrypoint could be missed due to the time discretization. So
        this correction will catch that case and perturb the sprites so they no
        longer intersect.

        Furthermore, sometimes if collisions with multiple sprites happen within
        one physics timestep, the collision misses one of them, so this
        perturbation comes in handy then to essentially push one of the
        collisions off until the next timestep.

        Finally, sometimes a sprite position may be macigally changed (e.g. by a
        discrete action space) to make it enter another sprite without moving
        there by its physics, so this correction is useful to separate the two
        overlapping sprites in that case as well.

        The way this function works is a bit ugly and not easy to describe. If
        you want to understand it, please draw out some examples on paper and
        see what the code does with them.

        Args:
            sprite_0: Instance of ../sprite.Sprite.
            sprite_1: Instance of ../sprite.Sprite.

        Returns:
            Boolean indicating whether the sprites were overlapping. This is
            useful for the calling code to know whether the sprie positions have
            been perturbed.
        &#34;&#34;&#34;
        crossing_points, inds_crossings = sprite_lib.sprite_edge_crossings(
            sprite_0, sprite_1)

        if len(inds_crossings) &lt;= 1:
            return True

        # correction_i is how much sprite_i must move (independent of sprite_j)
        # for the two to be disjoint.
        correction_0 = _position_correction(
            crossing_points,
            sprite_0,
            inds_crossings[:, 0],
            sprite_1,
            inds_crossings[:, 1])
        correction_1 = _position_correction(
            crossing_points,
            sprite_1,
            inds_crossings[:, 1],
            sprite_0,
            inds_crossings[:, 0])

        if np.linalg.norm(correction_0) &gt; np.linalg.norm(correction_1):
            correction = -1 * (1 + _EPSILON) * correction_0
        else:
            correction = (1 + _EPSILON) * correction_0
        
        if not all(np.isfinite(correction)):  # no correction needed
            correction = np.zeros(2)
        
        if self._symmetric:
            sprite_0.position = sprite_0.position + 0.5 * correction
            sprite_1.position = sprite_1.position - 0.5 * correction
        else:
            sprite_0.position = sprite_0.position + correction
        
        return False</code></pre>
</details>
<div class="desc"><p>Collision simulator.</p>
<p>This class simulates Newtonian collisions between two rigid bodies, namely
sprites in the environment. The physics assumes that the sprites have
uniform density, as this is important for calculating their moments of
inertia (see ../sprite for details).</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elasticity</code></strong></dt>
<dd>Float in [0, 1]. Elasticity 1 means the sprites bounce
fully. Elasticity 0 means they stick together completely.</dd>
<dt><strong><code>symmetric</code></strong></dt>
<dd>Bool. If True, collision is symmetric and both sprites
are updated. If False, sprite_1 in .step() is treated as having
infinite mass. This is useful for modeling bounces off of
obstructors/walls that are fixed in the environment.</dd>
<dt><strong><code>update_angle_vel</code></strong></dt>
<dd>Bool. If True, fully simulate the rotational
mechanics and update the sprites angular velocity. If False,
sprite angular velocities are not updated and the collision is
treated as if the contact point was between the two sprites'
centers of mass. Simulating the full rotational mechanics is
slightly slower.</dd>
<dt><strong><code>max_recursion_depth</code></strong></dt>
<dd>Int. Number of times self.step() may recurse.
Usually, 0 (no recursion) is fine. However, larger values make
the collisions slightly more accurate (at the expense of runtime
efficiency) if multiple collisions are happening within a single
step, e.g. colliding into a corner.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moog.physics.abstract_force.AbstractForce" href="abstract_force.html#moog.physics.abstract_force.AbstractForce">AbstractForce</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moog.physics.collisions.Collision.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, sprite_0, sprite_1, updates_per_env_step, recursion_depth=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, sprite_0, sprite_1, updates_per_env_step, recursion_depth=0):
    &#34;&#34;&#34;Step the physics.
    
    Args:
        sprite_0: Instance of ../sprite.Sprite. If self._symmetric = False,
            this sprite is the one that is doing the colliding, i.e. this
            one&#39;s velocity changes.
        sprite_1: Instance of ../sprite.Sprite. If self._symmetric = False,
            this sprite is treated as having infinite mass.
        updates_per_env_step: Int. Number of times this force step is called
            for each step of the physics in the environment. This is used
            here for inferring the exact contact point in the collision.
        recursion_depth: Int. Number of times this function has recursed.
            Used internally only to catch and avoid max recursion depth
            errors.
    &#34;&#34;&#34;
    if recursion_depth &gt; self._max_recursion_depth:
        return

    if sprite_0 == sprite_1:
        return

    if not sprite_0.overlaps_sprite(sprite_1):
        return

    delta_t = 1. / updates_per_env_step

    # First get collision point, normal, and relative sprite displacement
    # since the collision
    collision_point, collision_normal, _, perpendicular = (
        _get_collision_vectors(sprite_0, sprite_1, delta_t))
    
    if collision_point is None:
        # Although the sprites do overlap, neither sprite contains any of
        # the other&#39;s vertices. This can happen when the sprites collide
        # exactly at two corners. This is annoying to handle because we must
        # infer which corner hit which face in between timesteps, but must
        # be done to ensure stability. See self._make_disjoint() for
        # details.
        self._make_disjoint(sprite_0, sprite_1)
    else:
        # Whether the collision point is in the future, in which case we
        # leave the sprites alone.
        future_collision_point = (
            np.isscalar(collision_normal) and np.isnan(collision_normal))

        if not future_collision_point:
            # There was a collision in the past, so we must simulate it
            # First, displace the sprites so they are no longer intersecting
            # Note that instead of perpendicular displacement we could use
            # since_collision. However, sometimes since_collision can have a
            # very acute angle and large magnitude due to angular velocity
            # or multiple collisions, so in prectice displacing by the
            # perpendicular is more stable.
            if self._symmetric:
                sprite_0.position = (
                    sprite_0.position - (0.5 + _EPSILON) * perpendicular)
                sprite_1.position = (
                    sprite_1.position + (0.5 + _EPSILON) * perpendicular)
            else:
                sprite_0.position = (
                    sprite_0.position - (1. + _EPSILON) * perpendicular)

            # Second, change sprite velocities and angular velocities per
            # Newtonian physics
            if self._update_angle_vel:
                _collide_with_update_angle_vel(
                    sprite_0,
                    sprite_1,
                    collision_point,
                    collision_normal,
                    elasticity=self._elasticity,
                    symmetric=self._symmetric,
                )
            else:
                _collide_without_update_angle_vel(
                    sprite_0,
                    sprite_1,
                    collision_point,
                    collision_normal,
                    elasticity=self._elasticity,
                    symmetric=self._symmetric,
                )
        else:
            return
        
    # After perturbing the sprite positions and velocities, we recursively
    # step again in case that perturbation has now created another
    # collision.
    self.step(sprite_0, sprite_1, updates_per_env_step,
              recursion_depth=recursion_depth + 1)</code></pre>
</details>
<div class="desc"><p>Step the physics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sprite_0</code></strong></dt>
<dd>Instance of ../sprite.Sprite. If self._symmetric = False,
this sprite is the one that is doing the colliding, i.e. this
one's velocity changes.</dd>
<dt><strong><code>sprite_1</code></strong></dt>
<dd>Instance of ../sprite.Sprite. If self._symmetric = False,
this sprite is treated as having infinite mass.</dd>
<dt><strong><code>updates_per_env_step</code></strong></dt>
<dd>Int. Number of times this force step is called
for each step of the physics in the environment. This is used
here for inferring the exact contact point in the collision.</dd>
<dt><strong><code>recursion_depth</code></strong></dt>
<dd>Int. Number of times this function has recursed.
Used internally only to catch and avoid max recursion depth
errors.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moog.physics.abstract_force.AbstractForce" href="abstract_force.html#moog.physics.abstract_force.AbstractForce">AbstractForce</a></b></code>:
<ul class="hlist">
<li><code><a title="moog.physics.abstract_force.AbstractForce.reset" href="abstract_force.html#moog.physics.abstract_force.AbstractForce.reset">reset</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moog.physics" href="index.html">moog.physics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="moog.physics.collisions.Collision" href="#moog.physics.collisions.Collision">Collision</a></code></h4>
<ul class="">
<li><code><a title="moog.physics.collisions.Collision.step" href="#moog.physics.collisions.Collision.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
