<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>moog.env_wrappers.simulation API documentation</title>
<meta name="description" content="Environment wrapper class that supports mental simulation â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moog.env_wrappers.simulation</code></h1>
</header>
<section id="section-intro">
<p>Environment wrapper class that supports mental simulation.</p>
<p>This wrapper is useful when running model-based RL algorithms, because it
provides a ground-truth model of the environment.</p>
<p>Note: If there is stochasticity in the environment (e.g. maybe your physics or
game rules have randomness), this will only take samples at each simulation
step, not representing the full distribution of possible simulations. You can
step and pop many times to estimate the distribution of possibilities.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Environment wrapper class that supports mental simulation.

This wrapper is useful when running model-based RL algorithms, because it
provides a ground-truth model of the environment.

Note: If there is stochasticity in the environment (e.g. maybe your physics or
game rules have randomness), this will only take samples at each simulation
step, not representing the full distribution of possible simulations. You can
step and pop many times to estimate the distribution of possibilities.
&#34;&#34;&#34;

import copy
from moog import env_wrappers


class SimulationEnvironment(env_wrappers.AbstractEnvironmentWrapper):
    &#34;&#34;&#34;Environment class supporting mental simulation.
    
    This wrapper supports the normal environment interface, but adds two
    additional methods:
        * sim_step(action): This takes a step in mental simulation, advancing
            the state and returning a timestep. However, it also keeps a
            representation of the current state in a stack, to allow for
            restoring later.
        * sim_pop(index=-1): This restores to a previous state in the mental
            simulation stack. Specifically, it restores to the state at level
            index. For example, if we&#39;ve called sim_step() two times, then
            sim_pop(-1) or sim_pop(1) would restore to the state after the first
            sim_step() call, whereas sim_pop(0) would restore the original state
            before both sim_step() calls.
    
    You can think of sim_step() and sim_pop() as allowing traversals through a
    tree of mental simulation.
    &#34;&#34;&#34;
    
    def __init__(self, environment):
        &#34;&#34;&#34;Constructor.

        Args:
            environment: Instance of ../moog/environment.Environment.
        &#34;&#34;&#34;
        super(SimulationEnvironment, self).__init__(environment)

    def reset(self):
        self.stack = []
        return super(SimulationEnvironment, self).reset()

    def step(self, action):
        &#34;&#34;&#34;Step the environment with an action.&#34;&#34;&#34;
        if self.stack:
            self.sim_pop(index=0)
        self.stack = []
        return super(SimulationEnvironment, self).step(action)
    
    def sim_step(self, action):
        &#34;&#34;&#34;Take a simulation step of the environment with an action.&#34;&#34;&#34;
        if self._environment.reset_next_step:
            # Should not simulate across episode boundaries
            return None
        self.stack.append({
            &#39;state&#39;: copy.deepcopy(self._environment.state),
            &#39;meta_state&#39;: copy.deepcopy(self._environment.meta_state),
            &#39;action_space&#39;: copy.deepcopy(self._environment.action_space),
            &#39;physics&#39;: copy.deepcopy(self._environment.physics),
            &#39;game_rules&#39;: copy.deepcopy(self._environment.game_rules),
            &#39;task&#39;: copy.deepcopy(self._environment.task),
            &#39;step_count&#39;: copy.deepcopy(self._environment.step_count),
            &#39;reset_next_step&#39;: copy.deepcopy(self._environment.reset_next_step),
        })
        return super(SimulationEnvironment, self).step(action)
    
    def sim_pop(self, index=-1):
        &#34;&#34;&#34;Pop and restore the state at index off the stack.&#34;&#34;&#34;
        restore_data = self.stack[index]
        self._environment._state = restore_data[&#39;state&#39;]
        self._environment.action_space = restore_data[&#39;action_space&#39;]
        self._environment.physics = restore_data[&#39;physics&#39;]
        self._environment.game_rules = restore_data[&#39;game_rules&#39;]
        self._environment.task = restore_data[&#39;task&#39;]
        self._environment._meta_state = restore_data[&#39;meta_state&#39;]  #pylint: disable=protected-access
        self._environment.step_count = restore_data[&#39;step_count&#39;]
        self._environment._reset_next_step = restore_data[&#39;reset_next_step&#39;]  #pylint: disable=protected-access
        self.stack = self.stack[:index]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="moog.env_wrappers.simulation.SimulationEnvironment"><code class="flex name class">
<span>class <span class="ident">SimulationEnvironment</span></span>
<span>(</span><span>environment)</span>
</code></dt>
<dd>
<div class="desc"><p>Environment class supporting mental simulation.</p>
<p>This wrapper supports the normal environment interface, but adds two
additional methods:
* sim_step(action): This takes a step in mental simulation, advancing
the state and returning a timestep. However, it also keeps a
representation of the current state in a stack, to allow for
restoring later.
* sim_pop(index=-1): This restores to a previous state in the mental
simulation stack. Specifically, it restores to the state at level
index. For example, if we've called sim_step() two times, then
sim_pop(-1) or sim_pop(1) would restore to the state after the first
sim_step() call, whereas sim_pop(0) would restore the original state
before both sim_step() calls.</p>
<p>You can think of sim_step() and sim_pop() as allowing traversals through a
tree of mental simulation.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>environment</code></strong></dt>
<dd>Instance of ../moog/environment.Environment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimulationEnvironment(env_wrappers.AbstractEnvironmentWrapper):
    &#34;&#34;&#34;Environment class supporting mental simulation.
    
    This wrapper supports the normal environment interface, but adds two
    additional methods:
        * sim_step(action): This takes a step in mental simulation, advancing
            the state and returning a timestep. However, it also keeps a
            representation of the current state in a stack, to allow for
            restoring later.
        * sim_pop(index=-1): This restores to a previous state in the mental
            simulation stack. Specifically, it restores to the state at level
            index. For example, if we&#39;ve called sim_step() two times, then
            sim_pop(-1) or sim_pop(1) would restore to the state after the first
            sim_step() call, whereas sim_pop(0) would restore the original state
            before both sim_step() calls.
    
    You can think of sim_step() and sim_pop() as allowing traversals through a
    tree of mental simulation.
    &#34;&#34;&#34;
    
    def __init__(self, environment):
        &#34;&#34;&#34;Constructor.

        Args:
            environment: Instance of ../moog/environment.Environment.
        &#34;&#34;&#34;
        super(SimulationEnvironment, self).__init__(environment)

    def reset(self):
        self.stack = []
        return super(SimulationEnvironment, self).reset()

    def step(self, action):
        &#34;&#34;&#34;Step the environment with an action.&#34;&#34;&#34;
        if self.stack:
            self.sim_pop(index=0)
        self.stack = []
        return super(SimulationEnvironment, self).step(action)
    
    def sim_step(self, action):
        &#34;&#34;&#34;Take a simulation step of the environment with an action.&#34;&#34;&#34;
        if self._environment.reset_next_step:
            # Should not simulate across episode boundaries
            return None
        self.stack.append({
            &#39;state&#39;: copy.deepcopy(self._environment.state),
            &#39;meta_state&#39;: copy.deepcopy(self._environment.meta_state),
            &#39;action_space&#39;: copy.deepcopy(self._environment.action_space),
            &#39;physics&#39;: copy.deepcopy(self._environment.physics),
            &#39;game_rules&#39;: copy.deepcopy(self._environment.game_rules),
            &#39;task&#39;: copy.deepcopy(self._environment.task),
            &#39;step_count&#39;: copy.deepcopy(self._environment.step_count),
            &#39;reset_next_step&#39;: copy.deepcopy(self._environment.reset_next_step),
        })
        return super(SimulationEnvironment, self).step(action)
    
    def sim_pop(self, index=-1):
        &#34;&#34;&#34;Pop and restore the state at index off the stack.&#34;&#34;&#34;
        restore_data = self.stack[index]
        self._environment._state = restore_data[&#39;state&#39;]
        self._environment.action_space = restore_data[&#39;action_space&#39;]
        self._environment.physics = restore_data[&#39;physics&#39;]
        self._environment.game_rules = restore_data[&#39;game_rules&#39;]
        self._environment.task = restore_data[&#39;task&#39;]
        self._environment._meta_state = restore_data[&#39;meta_state&#39;]  #pylint: disable=protected-access
        self._environment.step_count = restore_data[&#39;step_count&#39;]
        self._environment._reset_next_step = restore_data[&#39;reset_next_step&#39;]  #pylint: disable=protected-access
        self.stack = self.stack[:index]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>moog.env_wrappers.abstract_wrapper.AbstractEnvironmentWrapper</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moog.env_wrappers.simulation.SimulationEnvironment.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.stack = []
    return super(SimulationEnvironment, self).reset()</code></pre>
</details>
</dd>
<dt id="moog.env_wrappers.simulation.SimulationEnvironment.sim_pop"><code class="name flex">
<span>def <span class="ident">sim_pop</span></span>(<span>self, index=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Pop and restore the state at index off the stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sim_pop(self, index=-1):
    &#34;&#34;&#34;Pop and restore the state at index off the stack.&#34;&#34;&#34;
    restore_data = self.stack[index]
    self._environment._state = restore_data[&#39;state&#39;]
    self._environment.action_space = restore_data[&#39;action_space&#39;]
    self._environment.physics = restore_data[&#39;physics&#39;]
    self._environment.game_rules = restore_data[&#39;game_rules&#39;]
    self._environment.task = restore_data[&#39;task&#39;]
    self._environment._meta_state = restore_data[&#39;meta_state&#39;]  #pylint: disable=protected-access
    self._environment.step_count = restore_data[&#39;step_count&#39;]
    self._environment._reset_next_step = restore_data[&#39;reset_next_step&#39;]  #pylint: disable=protected-access
    self.stack = self.stack[:index]</code></pre>
</details>
</dd>
<dt id="moog.env_wrappers.simulation.SimulationEnvironment.sim_step"><code class="name flex">
<span>def <span class="ident">sim_step</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a simulation step of the environment with an action.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sim_step(self, action):
    &#34;&#34;&#34;Take a simulation step of the environment with an action.&#34;&#34;&#34;
    if self._environment.reset_next_step:
        # Should not simulate across episode boundaries
        return None
    self.stack.append({
        &#39;state&#39;: copy.deepcopy(self._environment.state),
        &#39;meta_state&#39;: copy.deepcopy(self._environment.meta_state),
        &#39;action_space&#39;: copy.deepcopy(self._environment.action_space),
        &#39;physics&#39;: copy.deepcopy(self._environment.physics),
        &#39;game_rules&#39;: copy.deepcopy(self._environment.game_rules),
        &#39;task&#39;: copy.deepcopy(self._environment.task),
        &#39;step_count&#39;: copy.deepcopy(self._environment.step_count),
        &#39;reset_next_step&#39;: copy.deepcopy(self._environment.reset_next_step),
    })
    return super(SimulationEnvironment, self).step(action)</code></pre>
</details>
</dd>
<dt id="moog.env_wrappers.simulation.SimulationEnvironment.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Step the environment with an action.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, action):
    &#34;&#34;&#34;Step the environment with an action.&#34;&#34;&#34;
    if self.stack:
        self.sim_pop(index=0)
    self.stack = []
    return super(SimulationEnvironment, self).step(action)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moog.env_wrappers" href="index.html">moog.env_wrappers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="moog.env_wrappers.simulation.SimulationEnvironment" href="#moog.env_wrappers.simulation.SimulationEnvironment">SimulationEnvironment</a></code></h4>
<ul class="">
<li><code><a title="moog.env_wrappers.simulation.SimulationEnvironment.reset" href="#moog.env_wrappers.simulation.SimulationEnvironment.reset">reset</a></code></li>
<li><code><a title="moog.env_wrappers.simulation.SimulationEnvironment.sim_pop" href="#moog.env_wrappers.simulation.SimulationEnvironment.sim_pop">sim_pop</a></code></li>
<li><code><a title="moog.env_wrappers.simulation.SimulationEnvironment.sim_step" href="#moog.env_wrappers.simulation.SimulationEnvironment.sim_step">sim_step</a></code></li>
<li><code><a title="moog.env_wrappers.simulation.SimulationEnvironment.step" href="#moog.env_wrappers.simulation.SimulationEnvironment.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
